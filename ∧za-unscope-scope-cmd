#!/usr/bin/env zsh
# -*- mode: sh; sh-indentation: 4; sh-basic-offset: 4; indent-tabs-mode: nil;  -*-

# Copyright (c) 2020 Sebastian Gniazdowski
# License: MIT

∧za-unscope-scope-cmd() {
    # Set the base and typically useful options.
    builtin emulate -LR zsh
    builtin setopt extendedglob warncreateglobal typesetsilent noshortloops rcquotes

    (( $+reply && $+REPLY )) || unsetopt warncreateglobal

    autoload -Uz is-at-least
    local is_58
    is-at-least 5.8 && is_58=1

    integer retval

    [[ $1 == scope ]] && shift

    # -D - clear out the recognized options
    # -E - allow mixing of options and non-options
    # -M - allow private arrays for the options
    #
    # The options are:
    # --with/--mod/-m/--use – to pass the desired module(s)
    local -a help no_api reply_only msg type list
    zparseopts -D -E -M ${is_58:+} -no-api=no_api n=no_api \
        -reply-ony=reply_only r=reply_only -msg=msg m=msg \
        -type=type t=type h=help -help=help -list=list l=list || retval=1
        if [[ $retval -gt 0 || $1 = -* ]] {
            +zinit-message "{nl}{error}unscope annex: {msg}Incorrect options" \
                "given${${(M)1:#-*}:+ "(bad option: {ehi}$1{rst}{msg})"}." \
                "Usage:{rst}{nl}"
            help=( -h ) retval=1
        }

    local id=${${1#@}%%(///|//|/)}

    # --help/-h
    if (( ${#help} )) || [[ -z $id ]] && (( !${#list} )) {
        if [[ -z $id ]] {
            +zinit-message "{ehi}unscope annex:{rst}{msg} Missing the ID to" \
                    "(un)scope. Usage:{rst}{nl}"
        }
        ∧za-unscope-scope-cmd-help-handler
        return retval
    }

    # --list/-l
    if (( ${#list} )) {
        .za-unscope-list-mappings
        return $?
    }

    local new_teleid_data=${(v)Zinit_Annex_Unscope_Mappings[(i)<->. ##$id]}

    if [[ -z $new_teleid_data ]] {
        local -a reply
        integer existed
        if .zinit-get-object-path snippet "$id"; then
            existed=1
            { new_teleid_data="$(<$reply[1]/$reply[2]/._zinit/dynamic-unscope)" } 2>/dev/null
        fi
        if [[ -z $new_teleid_data ]] {
            if .zinit-get-object-path plugin "$id"; then
                existed=1
                { new_teleid_data="$(<$reply[1]/._zinit/dynamic-unscope)" } 2>/dev/null
            fi
        }

        [[ -n $new_teleid_data ]] && integer from_disk=1

        if (( !existed && !${#no_api} )) {
            .za-scope-dynamic ${${(M)${#msg}:#0}:+-q} "$id"
            if (( 0 == status )) {
                new_teleid_data=$REPLY\ 0
                (( ${+ZINIT_ICE} )) && ZINIT_ICE[dynamic-unscope]=$REPLY\ 0
                integer from_dynamic=1
            }
        }
    } else {
        integer from_static=1
    }

    if (( !${#reply_only} )) {
        if [[ -n $new_teleid_data ]] {
            (($+functions[.zinit-two-paths])) || builtin source $ZINIT[BIN_DIR]/zinit-side.zsh

            local -a object_data
            object_data=( "${(@Q)${(@z)new_teleid_data}}" )
            .zinit-any-colorify-as-uspl2 "$object_data[1]"
            (( from_dynamic )) && local msg_bit=" ({meta2}GH-API{msg})"
            (( from_disk )) && local msg_bit=" (stored {meta2}GH-API{msg})"
            (( from_static )) && local msg_bit=" ({meta2}static map{msg})"

            +zinit-message "{pre}unscope annex: {msg}The key{ehi}:{rst}" \
            "{data}$id{msg} matched$msg_bit to{ehi}:{rst}" \
            "$REPLY{msg}.{rst}"
        } else {
            +zinit-message "{pre}unscope annex: {msg}Didn't find any match" \
                    "for the given key{ehi}:{rst} {data}$id{msg}.{rst}"
        }
    }
    REPLY=${${type:+$new_teleid_data}:-${new_teleid_data%%\ ##<->}}
    [[ -n $REPLY ]]
}

# vim:ft=zsh:sw=4:sts=4:et:
